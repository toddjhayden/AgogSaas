const fs = require('fs');
const { Pool } = require('pg');

const pool = new Pool({
  host: 'localhost',
  port: 5434,
  user: 'agent_user',
  password: 'agent_dev_password_2024',
  database: 'agent_memory'
});

async function main() {
  const content = fs.readFileSync('project-spirit/owner_requests/OWNER_REQUESTS.md', 'utf8');

  // Get header content before first REQ
  const headerMatch = content.match(/^([\s\S]*?)(?=### REQ-)/);
  const header = headerMatch ? headerMatch[1] : '';

  // Split by REQ entries
  const sections = content.split(/(?=### REQ-)/);

  const completeReqs = [];
  const activeReqs = [];

  for (const section of sections) {
    if (!section.trim().startsWith('### REQ-')) continue;

    const reqMatch = section.match(/### (REQ-[^:]+):\s*(.+)/);
    if (!reqMatch) continue;

    const reqNumber = reqMatch[1];
    const title = reqMatch[2].trim();

    const statusMatch = section.match(/\*\*Status\*\*:\s*(\w+)/);
    const status = statusMatch ? statusMatch[1] : 'UNKNOWN';

    const ownerMatch = section.match(/\*\*Owner\*\*:\s*(\w+)/);
    const owner = ownerMatch ? ownerMatch[1] : null;

    const priorityMatch = section.match(/\*\*Priority\*\*:\s*(\w+)/);
    const priority = priorityMatch ? priorityMatch[1] : null;

    const businessValueMatch = section.match(/\*\*Business Value\*\*:\s*([^\n]+)/);
    const businessValue = businessValueMatch ? businessValueMatch[1].trim() : null;

    const generatedByMatch = section.match(/\*\*Generated By\*\*:\s*([^\n]+)/);
    const generatedBy = generatedByMatch ? generatedByMatch[1].trim() : null;

    const generatedAtMatch = section.match(/\*\*Generated At\*\*:\s*([^\n]+)/);
    const generatedAt = generatedAtMatch ? generatedAtMatch[1].trim() : null;

    const requirementsMatch = section.match(/\*\*Requirements\*\*:\s*([\s\S]*?)(?=\*\*Success Criteria\*\*|\*\*Strategic Impact\*\*|---|\$)/);
    const requirements = requirementsMatch ? requirementsMatch[1].trim().split(/\n- /).filter(r => r.trim()) : [];

    const req = {
      reqNumber,
      title,
      status,
      owner,
      priority,
      businessValue,
      generatedBy,
      generatedAt,
      requirements,
      fullContent: section.trim()
    };

    if (status === 'COMPLETE') {
      completeReqs.push(req);
    } else {
      activeReqs.push(req);
    }
  }

  console.log('Complete REQs found:', completeReqs.length);
  console.log('Active REQs found:', activeReqs.length);

  // Insert complete REQs into database
  let inserted = 0;
  let skipped = 0;

  for (const req of completeReqs) {
    try {
      await pool.query(`
        INSERT INTO archived_requirements
        (req_number, title, status, owner, priority, business_value, requirements, generated_by, generated_at, completed_at, full_content)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), $10)
        ON CONFLICT (req_number) DO NOTHING
      `, [
        req.reqNumber,
        req.title,
        req.status,
        req.owner,
        req.priority,
        req.businessValue,
        JSON.stringify(req.requirements),
        req.generatedBy,
        req.generatedAt ? new Date(req.generatedAt) : null,
        req.fullContent
      ]);
      inserted++;
    } catch (err) {
      if (err.code === '23505') { // Unique violation
        skipped++;
      } else {
        console.error('Error inserting', req.reqNumber, err.message);
      }
    }
  }

  console.log('Inserted:', inserted);
  console.log('Skipped (duplicates):', skipped);

  // Generate new OWNER_REQUESTS.md with only active REQs
  let newContent = header;
  for (const req of activeReqs) {
    newContent += req.fullContent + '\n\n---\n\n';
  }

  // Write the new file
  fs.writeFileSync('project-spirit/owner_requests/OWNER_REQUESTS.md', newContent.trim() + '\n');

  console.log('Updated OWNER_REQUESTS.md with', activeReqs.length, 'active REQs');
  console.log('Archived', completeReqs.length, 'complete REQs to database');

  await pool.end();
}

main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});
