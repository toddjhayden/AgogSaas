# Saga Pattern GraphQL Schema
# REQ-1767541724201-s8kck - Implement End-to-End Demand-to-Cash Saga Pattern

type SagaDefinition {
  id: ID!
  tenantId: ID!
  sagaName: String!
  description: String
  version: Int!
  isActive: Boolean!
  stepsConfig: [SagaStepConfig!]!
  timeoutSeconds: Int
  maxRetries: Int
  retryDelaySeconds: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SagaStepConfig {
  stepName: String!
  description: String
  serviceType: String!
  serviceName: String
  serviceUrl: String
  agentName: String
  forwardAction: String!
  compensationAction: String!
  timeout: Int
  retryable: Boolean!
  maxRetries: Int
}

type SagaInstance {
  id: ID!
  tenantId: ID!
  sagaDefinitionId: ID!
  sagaName: String!
  sagaVersion: Int!
  status: SagaStatus!
  currentStepIndex: Int!
  contextEntityType: String
  contextEntityId: ID
  sagaContext: JSON!
  startedAt: DateTime!
  completedAt: DateTime
  failedAt: DateTime
  compensatedAt: DateTime
  errorMessage: String
  deadline: DateTime
  retryCount: Int!
  createdBy: ID
  updatedAt: DateTime!

  # Computed fields
  steps: [SagaStepExecution!]!
  events: [SagaEventLog!]!
}

enum SagaStatus {
  STARTED
  RUNNING
  COMPENSATING
  COMPLETED
  FAILED
  COMPENSATED
}

type SagaStepExecution {
  id: ID!
  sagaInstanceId: ID!
  stepIndex: Int!
  stepName: String!
  status: StepStatus!
  executionType: ExecutionType!
  inputData: JSON
  outputData: JSON
  startedAt: DateTime
  completedAt: DateTime
  failedAt: DateTime
  compensatedAt: DateTime
  errorMessage: String
  retryCount: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum StepStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  COMPENSATING
  COMPENSATED
  COMPENSATION_FAILED
}

enum ExecutionType {
  FORWARD
  COMPENSATION
}

type SagaEventLog {
  id: ID!
  sagaInstanceId: ID!
  stepExecutionId: ID
  eventType: String!
  eventData: JSON
  createdAt: DateTime!
  createdBy: ID
}

type SagaExecutionResult {
  sagaInstanceId: ID!
  status: SagaStatus!
  completedSteps: Int!
  totalSteps: Int!
  errorMessage: String
}

# Demand-to-Cash specific inputs
input DemandToCashQuoteItemInput {
  productId: ID!
  quantity: Float!
  unitPrice: Float!
  description: String!
}

input DemandToCashQuoteInput {
  items: [DemandToCashQuoteItemInput!]!
  validUntil: DateTime!
  notes: String
}

input StartDemandToCashSagaInput {
  tenantId: ID!
  facilityId: ID!
  customerId: ID!
  quoteData: DemandToCashQuoteInput!
}

type Query {
  # Get saga instance by ID
  sagaInstance(id: ID!): SagaInstance

  # List saga instances with filters
  sagaInstances(
    tenantId: ID!
    status: SagaStatus
    sagaName: String
    limit: Int = 50
    offset: Int = 0
  ): [SagaInstance!]!

  # Get saga definitions
  sagaDefinitions(tenantId: ID!): [SagaDefinition!]!

  # Get saga events for an instance
  sagaEvents(sagaInstanceId: ID!): [SagaEventLog!]!
}

type Mutation {
  # Start a demand-to-cash saga
  startDemandToCashSaga(input: StartDemandToCashSagaInput!): SagaExecutionResult!

  # Retry a failed saga
  retrySaga(sagaInstanceId: ID!): SagaExecutionResult!

  # Cancel a running saga (triggers compensation)
  cancelSaga(sagaInstanceId: ID!, reason: String!): SagaExecutionResult!
}
