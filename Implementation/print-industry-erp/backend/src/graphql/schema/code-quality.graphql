# Code Quality & Quality Gates Schema
# REQ-STRATEGIC-AUTO-1767108044307

type QualityMetrics {
  reqNumber: String!
  commitSha: String!
  branch: String!
  author: String!
  timestamp: DateTime!
  coverage: CoverageMetrics!
  complexity: ComplexityMetrics!
  linting: LintingMetrics!
  security: SecurityMetrics!
  performance: PerformanceMetrics!
  qualityGatePassed: Boolean!
  blockedReasons: [String!]!
}

type CoverageMetrics {
  line: Float!
  branch: Float!
  function: Float!
  statement: Float!
}

type ComplexityMetrics {
  max: Int!
  avg: Float!
  violations: [ComplexityViolation!]!
}

type ComplexityViolation {
  file: String!
  function: String!
  complexity: Int!
  threshold: Int!
}

type LintingMetrics {
  errors: Int!
  warnings: Int!
  issues: [LintIssue!]!
}

type LintIssue {
  file: String!
  line: Int!
  rule: String!
  message: String!
  severity: LintSeverity!
}

enum LintSeverity {
  error
  warning
}

type SecurityMetrics {
  critical: Int!
  high: Int!
  medium: Int!
  low: Int!
  vulnerabilities: [SecurityVulnerability!]!
}

type SecurityVulnerability {
  package: String!
  severity: String!
  title: String!
  cve: String
}

type PerformanceMetrics {
  buildTime: Int!
  bundleSize: Int
  avgTestDuration: Int
}

enum ValidationStatus {
  PENDING
  PASSED
  FAILED_LINTING
  FAILED_TESTS
  FAILED_COMPLEXITY
  FAILED_COVERAGE
  FAILED_SECURITY
  TIMEOUT
  ERROR
}

type QualityGateValidation {
  id: ID!
  reqNumber: String!
  agentName: String!
  deliverableUrl: String
  status: ValidationStatus!
  validationStartedAt: DateTime
  validationCompletedAt: DateTime
  validationDurationMs: Int
  lintingPassed: Boolean
  lintingErrors: [String!]
  typeCheckingPassed: Boolean
  typeCheckingErrors: [String!]
  unitTestsPassed: Boolean
  unitTestFailures: [String!]
  complexityCheckPassed: Boolean
  complexityViolations: [String!]
  coverageCheckPassed: Boolean
  coverageFailures: [String!]
  securityCheckPassed: Boolean
  securityViolations: [String!]
  overallPassed: Boolean!
  failureReasons: [String!]
  recommendations: [String!]
  filesCreated: [String!]
  filesModified: [String!]
  filesDeleted: [String!]
  createdAt: DateTime!
}

type QualityGateConfig {
  id: ID!
  name: String!
  description: String
  enabled: Boolean!
  minLineCoverage: Float!
  minBranchCoverage: Float!
  minFunctionCoverage: Float!
  minNewCodeCoverage: Float!
  maxCyclomaticComplexity: Int!
  maxCognitiveComplexity: Int!
  maxLinesPerFunction: Int!
  maxFileLength: Int!
  maxCriticalVulnerabilities: Int!
  maxHighVulnerabilities: Int!
  maxBundleSizeKb: Int!
  maxApiResponseP95Ms: Int!
  maxSlowQueryMs: Int!
  maxCiPipelineMinutes: Int!
  maxCodeSmells: Int!
  maxTechnicalDebtRatio: Float!
  maxDuplicatedCodePct: Float!
}

type QualityGateStatus {
  passed: Boolean!
  gates: [QualityGate!]!
}

type QualityGate {
  name: String!
  passed: Boolean!
  threshold: Float!
  actualValue: Float!
  severity: Severity!
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type AgentQualityScore {
  agentName: String!
  timePeriod: String!
  periodStart: DateTime!
  periodEnd: DateTime!
  totalDeliverables: Int!
  passedQualityGates: Int!
  failedQualityGates: Int!
  bypassedQualityGates: Int!
  qualityGatePassRate: Float!
  avgQualityScore: Float!
  avgLineCoverage: Float!
  avgBranchCoverage: Float!
  avgComplexity: Float!
  complexityViolationCount: Int!
  totalVulnerabilitiesFound: Int!
  criticalVulnerabilitiesFound: Int!
  avgValidationTimeMs: Int!
}

type AgentQualityPassRate {
  agentName: String!
  totalValidations: Int!
  passedValidations: Int!
  failedValidations: Int!
  passRatePct: Float!
  avgValidationTimeMs: Float!
}

type QualityMetricsTrend {
  reqNumber: String!
  commitSha: String!
  createdAt: DateTime!
  lineCoverage: Float
  maxComplexity: Int
  totalLintIssues: Int!
  criticalSecurityIssues: Int!
  qualityGatePassed: Boolean!
  statusSummary: String!
}

type QualityGateBypass {
  id: ID!
  reqNumber: String!
  validationId: String
  bypassReason: String!
  bypassedBy: String!
  approvedBy: [String!]!
  bypassedViolations: [String!]!
  followUpIssueNumber: String
  followUpDueDate: DateTime
  followUpCompleted: Boolean!
  postmortemCompleted: Boolean!
  postmortemUrl: String
  bypassedAt: DateTime!
  resolvedAt: DateTime
}

type QualityGateBypassRate {
  month: DateTime!
  totalBypasses: Int!
  resolvedBypasses: Int!
  unresolvedBypasses: Int!
  postmortemCompletionRate: Float!
}

type GraphQLSchemaChange {
  id: ID!
  reqNumber: String!
  commitSha: String!
  breakingChanges: [SchemaChange!]!
  dangerousChanges: [SchemaChange!]!
  safeChanges: [SchemaChange!]!
  isBreaking: Boolean!
  frontendCompatible: Boolean!
  previousSchemaHash: String
  newSchemaHash: String!
  validatedAt: DateTime!
  validatedBy: String
  contractTestsPassed: Boolean
}

type SchemaChange {
  type: String!
  description: String!
  path: String
}

type CIPipelineMetrics {
  id: ID!
  reqNumber: String
  commitSha: String!
  branch: String!
  pipelineId: String!
  pipelineUrl: String
  pipelineType: PipelineType!
  startedAt: DateTime!
  completedAt: DateTime
  totalDurationSeconds: Int
  lintDurationSeconds: Int
  testDurationSeconds: Int
  buildDurationSeconds: Int
  securityScanDurationSeconds: Int
  qualityAnalysisDurationSeconds: Int
  cacheHitRate: Float
  cacheSizeMb: Int
  status: PipelineStatus!
  failedJobs: [String!]
}

enum PipelineType {
  fast_feedback
  comprehensive
}

enum PipelineStatus {
  success
  failure
  cancelled
}

input QualityMetricsInput {
  reqNumber: String!
  commitSha: String!
  branch: String!
  author: String!
  coverage: CoverageMetricsInput!
  complexity: ComplexityMetricsInput!
  linting: LintingMetricsInput!
  security: SecurityMetricsInput!
  performance: PerformanceMetricsInput!
}

input CoverageMetricsInput {
  line: Float!
  branch: Float!
  function: Float!
  statement: Float!
}

input ComplexityMetricsInput {
  max: Int!
  avg: Float!
  violations: [ComplexityViolationInput!]!
}

input ComplexityViolationInput {
  file: String!
  function: String!
  complexity: Int!
  threshold: Int!
}

input LintingMetricsInput {
  errors: Int!
  warnings: Int!
  issues: [LintIssueInput!]!
}

input LintIssueInput {
  file: String!
  line: Int!
  rule: String!
  message: String!
  severity: LintSeverity!
}

input SecurityMetricsInput {
  critical: Int!
  high: Int!
  medium: Int!
  low: Int!
  vulnerabilities: [SecurityVulnerabilityInput!]!
}

input SecurityVulnerabilityInput {
  package: String!
  severity: String!
  title: String!
  cve: String
}

input PerformanceMetricsInput {
  buildTime: Int!
  bundleSize: Int
  avgTestDuration: Int
}

extend type Query {
  # Quality Metrics
  qualityMetrics(reqNumber: String!): [QualityMetrics!]!
  latestQualityMetrics(reqNumber: String!): QualityMetrics
  qualityMetricsTrends(limit: Int = 100): [QualityMetricsTrend!]!

  # Quality Gate Configuration
  activeQualityGateConfig: QualityGateConfig
  qualityGateStatus(reqNumber: String!): QualityGateStatus!

  # Quality Gate Validations
  qualityGateValidation(id: ID!): QualityGateValidation
  qualityGateValidations(
    reqNumber: String
    agentName: String
    status: ValidationStatus
    limit: Int = 50
  ): [QualityGateValidation!]!

  # Agent Quality Scores
  agentQualityScores(
    agentName: String
    timePeriod: String = "monthly"
  ): [AgentQualityScore!]!
  agentQualityPassRates: [AgentQualityPassRate!]!

  # Quality Gate Bypasses
  qualityGateBypasses(
    reqNumber: String
    unresolvedOnly: Boolean = false
    limit: Int = 50
  ): [QualityGateBypass!]!
  qualityGateBypassRates: [QualityGateBypassRate!]!

  # GraphQL Schema Changes
  graphqlSchemaChanges(
    reqNumber: String
    breakingOnly: Boolean = false
    limit: Int = 50
  ): [GraphQLSchemaChange!]!

  # CI/CD Pipeline Metrics
  ciPipelineMetrics(
    reqNumber: String
    pipelineType: PipelineType
    limit: Int = 50
  ): [CIPipelineMetrics!]!
}

extend type Mutation {
  # Submit quality metrics (typically from CI/CD)
  submitQualityMetrics(metrics: QualityMetricsInput!): QualityMetrics!

  # Quality Gate Bypass (emergency use only)
  requestQualityGateBypass(
    reqNumber: String!
    validationId: String
    reason: String!
    bypassedViolations: [String!]!
  ): QualityGateBypass!

  approveQualityGateBypass(
    bypassId: ID!
    approverId: String!
  ): QualityGateBypass!
}
