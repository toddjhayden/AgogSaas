# =====================================================
# JOB COSTING MODULE - GraphQL Schema
# REQ-STRATEGIC-AUTO-1767048328661
# =====================================================

type JobCost {
  id: ID!
  tenantId: ID!
  jobId: ID!
  job: Job!
  estimateId: ID
  estimate: Estimate

  # Revenue
  totalAmount: Float!

  # Actual Costs
  totalCost: Float!
  materialCost: Float!
  laborCost: Float!
  equipmentCost: Float!
  overheadCost: Float!
  outsourcingCost: Float!
  otherCost: Float!

  # Estimated Costs
  estimatedMaterialCost: Float
  estimatedLaborCost: Float
  estimatedEquipmentCost: Float
  estimatedOverheadCost: Float
  estimatedOutsourcingCost: Float
  estimatedTotalCost: Float

  # Profitability Metrics (Generated Columns)
  grossProfit: Float!
  grossProfitMargin: Float!
  costVariance: Float
  costVariancePercentage: Float
  materialVariance: Float
  laborVariance: Float
  equipmentVariance: Float

  # Status
  status: JobCostStatus!
  costingDate: DateTime
  notes: String

  # Reconciliation
  isReconciled: Boolean!
  reconciledAt: DateTime
  reconciledBy: ID

  # Rollup Tracking
  lastRollupAt: DateTime
  lastRollupSource: RollupSource

  # Final Adjustments
  finalAdjustments: [CostAdjustment!]

  # Breakdown
  costBreakdown: [CostLineItem!]!
  costHistory: [JobCostUpdate!]!

  # Audit
  createdAt: DateTime!
  updatedAt: DateTime!
  completedAt: DateTime
  createdBy: ID
  updatedBy: ID
}

type CostLineItem {
  costCategory: CostCategory!
  estimatedCost: Float!
  actualCost: Float!
  variance: Float!
  variancePercentage: Float!
}

type CostAdjustment {
  adjustmentType: String!
  amount: Float!
  reason: String
  adjustedBy: ID
  adjustedAt: DateTime
}

type JobCostUpdate {
  id: ID!
  tenantId: ID!
  jobCostId: ID!

  # Update Info
  updateSource: UpdateSource!
  sourceId: ID
  costCategory: CostCategory!
  costDelta: Float!

  # Before/After
  previousTotal: Float!
  newTotal: Float!

  # Details
  quantity: Float
  unitCost: Float
  description: String
  updateMetadata: JSON

  # Audit
  createdAt: DateTime!
  createdBy: ID
}

type JobProfitability {
  jobId: ID!
  jobNumber: String!
  customerName: String!
  jobDescription: String

  # Financial Metrics
  revenue: Float!
  totalCost: Float!
  grossProfit: Float!
  grossMargin: Float!

  # Variance
  estimatedCost: Float
  costVariance: Float
  costVariancePercentage: Float

  # Status
  status: JobCostStatus!
  costingDate: DateTime
}

type VarianceReport {
  jobs: [JobProfitability!]!
  summary: VarianceSummary!
}

type VarianceSummary {
  totalJobs: Int!
  totalRevenue: Float!
  totalCost: Float!
  totalProfit: Float!
  avgMargin: Float!
  minMargin: Float
  maxMargin: Float
  medianMargin: Float
  totalVariance: Float!
  jobsOverBudget: Int!
  jobsUnderBudget: Int!
  jobsOnBudget: Int!
}

type Job {
  id: ID!
  jobNumber: String!
  customerName: String
  status: String
  estimatedCost: Float
  actualCost: Float
}

# =====================================================
# ENUMS
# =====================================================

enum JobCostStatus {
  ESTIMATED
  IN_PROGRESS
  COMPLETED
  REVIEWED
  APPROVED
  CLOSED
}

enum CostCategory {
  MATERIAL
  LABOR
  EQUIPMENT
  OVERHEAD
  OUTSOURCING
  OTHER
}

enum UpdateSource {
  PRODUCTION_ORDER
  MATERIAL_CONSUMPTION
  LABOR_TRACKING
  MANUAL
  ADJUSTMENT
}

enum RollupSource {
  MANUAL
  PRODUCTION_ORDER
  MATERIAL_CONSUMPTION
  LABOR_TRACKING
}

# =====================================================
# INPUTS
# =====================================================

input ActualCostInput {
  materialCost: Float
  laborCost: Float
  equipmentCost: Float
  overheadCost: Float
  outsourcingCost: Float
  otherCost: Float
}

input IncrementalCostInput {
  costCategory: CostCategory!
  costDelta: Float!
  updateSource: UpdateSource!
  sourceId: ID
  quantity: Float
  unitCost: Float
  description: String
  metadata: JSON
}

input VarianceReportFilters {
  dateFrom: Date
  dateTo: Date
  customerId: ID
  minVariancePercentage: Float
  status: JobCostStatus
}

input JobCostFilters {
  status: JobCostStatus
  dateFrom: Date
  dateTo: Date
  minVariancePercentage: Float
  isReconciled: Boolean
}

input FinalAdjustmentInput {
  adjustmentType: String!
  amount: Float!
  reason: String
}

# =====================================================
# QUERIES
# =====================================================

extend type Query {
  jobCost(jobId: ID!): JobCost
  jobCosts(filters: JobCostFilters, limit: Int, offset: Int): [JobCost!]!
  jobProfitability(jobId: ID!): JobProfitability!
  varianceReport(filters: VarianceReportFilters): VarianceReport!
  jobCostHistory(jobId: ID!): [JobCostUpdate!]!
}

# =====================================================
# MUTATIONS
# =====================================================

extend type Mutation {
  # Initialization
  initializeJobCost(jobId: ID!, estimateId: ID): JobCost!

  # Cost Updates
  updateActualCosts(jobId: ID!, costs: ActualCostInput!): JobCost!
  incrementCost(jobId: ID!, input: IncrementalCostInput!): JobCost!
  rollupProductionCosts(jobId: ID!): JobCost!

  # Adjustments
  addFinalAdjustment(jobId: ID!, adjustment: FinalAdjustmentInput!): JobCost!

  # Reconciliation
  reconcileJobCost(jobId: ID!): JobCost!

  # Closing
  closeJobCosting(jobId: ID!): JobCost!

  # Status Management
  updateJobCostStatus(jobId: ID!, status: JobCostStatus!): JobCost!
}

# =====================================================
# SUBSCRIPTIONS
# =====================================================

extend type Subscription {
  jobCostUpdated(jobId: ID!): JobCost!
  varianceAlert(threshold: Float!): VarianceAlert!
}

type VarianceAlert {
  jobId: ID!
  jobNumber: String!
  costCategory: CostCategory!
  variancePercentage: Float!
  threshold: Float!
  timestamp: DateTime!
}
