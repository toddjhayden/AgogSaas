/**
 * Recommendation Publisher
 * Subscribes to agent recommendations and appends to PENDING_RECOMMENDATIONS.md
 * Closes the loop on autonomous work generation
 */

import { connect, NatsConnection } from 'nats';
import * as fs from 'fs';

export interface Recommendation {
  reqNumber: string;
  title: string;
  owner: 'marcus' | 'sarah' | 'alex';
  priority: 'P0' | 'P1' | 'P2' | 'P3';
  businessValue: string;
  requirements: string[];
  generatedBy: string;
  generatedAt: string;
}

export class RecommendationPublisherService {
  private nc!: NatsConnection;
  private isRunning = false;
  private pendingRecommendationsPath = process.env.PENDING_RECOMMENDATIONS_PATH || '/app/project-spirit/owner_requests/PENDING_RECOMMENDATIONS.md';

  async initialize(): Promise<void> {
    const natsUrl = process.env.NATS_URL || 'nats://localhost:4223';
    const user = process.env.NATS_USER;
    const pass = process.env.NATS_PASSWORD;

    this.nc = await connect({
      servers: natsUrl,
      user,
      pass,
      name: 'recommendation-publisher'
    });

    console.log('[RecommendationPublisher] Connected to NATS');
  }

  /**
   * Start listening for recommendations
   */
  async startDaemon(): Promise<void> {
    if (this.isRunning) {
      console.log('[RecommendationPublisher] Already running');
      return;
    }

    this.isRunning = true;
    console.log('[RecommendationPublisher] Starting daemon...');

    // Subscribe to all recommendation streams
    await this.subscribeToRecommendations('strategic'); // value-chain-expert
    await this.subscribeToRecommendations('inventory');  // Marcus-po
    await this.subscribeToRecommendations('sales');      // Sarah-po
    await this.subscribeToRecommendations('procurement'); // Alex-po

    console.log('[RecommendationPublisher] ✅ Subscribed to all recommendation streams');
  }

  /**
   * Subscribe to a recommendation stream
   */
  private async subscribeToRecommendations(domain: string): Promise<void> {
    const subject = `agog.recommendations.${domain}`;

    const sub = this.nc.subscribe(subject);

    (async () => {
      for await (const msg of sub) {
        try {
          const recommendation = JSON.parse(msg.string());
          console.log(`[RecommendationPublisher] Received recommendation from ${domain}: ${recommendation.reqNumber}`);

          await this.processRecommendation(recommendation);
        } catch (error: any) {
          console.error(`[RecommendationPublisher] Error processing ${domain} recommendation:`, error.message);
        }
      }
    })();

    console.log(`[RecommendationPublisher] Subscribed to ${subject}`);
  }

  /**
   * Process a recommendation and append to PENDING_RECOMMENDATIONS.md
   */
  private async processRecommendation(rec: Recommendation): Promise<void> {
    // Check for duplicates
    if (await this.isDuplicate(rec.reqNumber)) {
      console.log(`[RecommendationPublisher] Duplicate detected: ${rec.reqNumber} - skipping`);
      return;
    }

    // Format recommendation as markdown
    const markdown = this.formatRecommendation(rec);

    // Append to PENDING_RECOMMENDATIONS.md
    await this.appendToPendingRecommendations(markdown);

    // Commit to git
    await this.commitRecommendation(rec);

    console.log(`[RecommendationPublisher] ✅ Published ${rec.reqNumber} to PENDING_RECOMMENDATIONS.md`);
  }

  /**
   * Check if recommendation already exists
   */
  private async isDuplicate(reqNumber: string): Promise<boolean> {
    if (!fs.existsSync(this.pendingRecommendationsPath)) {
      return false;
    }

    const content = fs.readFileSync(this.pendingRecommendationsPath, 'utf-8');
    return content.includes(reqNumber);
  }

  /**
   * Format recommendation as markdown
   */
  private formatRecommendation(rec: Recommendation): string {
    const status = (rec.priority === 'P0' || rec.priority === 'P1') ? 'PENDING' : 'NEW';
    const requirements = rec.requirements.map(r => `- ${r}`).join('\n');

    return `
### ${rec.reqNumber}: ${rec.title}

**Status**: ${status}
**Owner**: ${rec.owner}
**Priority**: ${rec.priority}
**Business Value**: ${rec.businessValue}
**Generated By**: ${rec.generatedBy}
**Generated At**: ${rec.generatedAt}

**Requirements**:

${requirements}

---
`;
  }

  /**
   * Append to PENDING_RECOMMENDATIONS.md
   */
  private async appendToPendingRecommendations(markdown: string): Promise<void> {
    if (!fs.existsSync(this.pendingRecommendationsPath)) {
      console.error(`[RecommendationPublisher] PENDING_RECOMMENDATIONS.md not found at ${this.pendingRecommendationsPath}`);
      return;
    }

    let content = fs.readFileSync(this.pendingRecommendationsPath, 'utf-8');

    // Insert before "## Completed Requests"
    const marker = '## Completed Requests';
    if (content.includes(marker)) {
      content = content.replace(marker, markdown + '\n' + marker);
    } else {
      // Fallback: append to end
      content += '\n' + markdown;
    }

    fs.writeFileSync(this.pendingRecommendationsPath, content, 'utf-8');
  }

  /**
   * Commit recommendation to git
   */
  private async commitRecommendation(rec: Recommendation): Promise<void> {
    try {
      const { execSync } = require('child_process');
      const cwd = process.env.OWNER_REQUESTS_DIR || '/app/project-spirit/owner_requests';

      execSync('git add PENDING_RECOMMENDATIONS.md', { cwd });
      execSync(`git commit -m "feat: Auto-generated recommendation ${rec.reqNumber} from ${rec.generatedBy}"`, { cwd });

      console.log(`[RecommendationPublisher] ✅ Committed ${rec.reqNumber} to git`);
    } catch (error: any) {
      console.error(`[RecommendationPublisher] Git commit failed:`, error.message);
    }
  }

  async stop(): Promise<void> {
    this.isRunning = false;
  }

  async close(): Promise<void> {
    await this.stop();
    await this.nc.close();
  }
}
